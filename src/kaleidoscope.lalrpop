use std::str::FromStr;
use crate::ast::*;

use std::rc::Rc;
grammar;

pub Prog: Rc<AstNode> = {
    <e:Extern*> <f:(Func+)> => Rc::new(AstNode::Prog{
        externs: e, 
        funcs: f,
    })
};

Extern: Rc<AstNode> = {
    // TODO tdecls
    "extern" <t:Type> <gid:GlobId> "(" ")" ";" => Rc::new(AstNode::Extern{
        type_: t,
        globid: gid,
        tdecls: None,
    })

}

Func: Rc<AstNode> = {
    "def" <t:Type> <gid:GlobId> "(" <vs:(VDecls)?> ")" <b:Blk> => Rc::new(AstNode::Func{
        type_: t,
        globid: gid,
        vdecls: vs,
        blk: b,
    }),
};

Blk: Rc<AstNode> = {
    "{" <s:(Stmts)?> "}" => Rc::new(AstNode::Blk{ stmts: s })
};

Stmts: Vec<Rc<AstNode>> = {
    <s:(Stmt)+> => s,
};

Stmt: Rc<AstNode> = {
    "return" <e:(Exp)?> ";" => Rc::new(AstNode::ReturnStmt{
        exp: e,
    }),
    // TODO other statement rules
};

Exp: Rc<AstNode> = {
    // TODO other expression rules
    <b:BinOp> => b,
    // <lit:Literal> => lit,
};

BinOp: Rc<AstNode> = {
    // TODO logic ops
    <a:ArithOps> => a,
};

// precedence 'c' in compiler spec
ArithOps: Rc<AstNode> = {
    <l:Exp> "+" <r:ArithFactor> => Rc::new(AstNode::BinOp{
        op: BOp::Add,
        lhs: l,
        rhs: r,
    }),
    <l:Exp> "-" <r:ArithFactor> => Rc::new(AstNode::BinOp{
        op: BOp::Sub,
        lhs: l,
        rhs: r,
    }),
    ArithFactor,
};

//TODO these can be done with macros (see section on Tier in the lalrpop tutorial)
// precedence 'd' in compiler spec
ArithFactor: Rc<AstNode> = {
    <l:ArithFactor> "*" <r:ArithTerm> => Rc::new(AstNode::BinOp{
        op: BOp::Mult,
        lhs: l,
        rhs: r,
    }),
    <l:ArithFactor> "/" <r:ArithTerm> => Rc::new(AstNode::BinOp{
        op: BOp::Div,
        lhs: l,
        rhs: r,
    }),
    ArithTerm,
};

ArithTerm: Rc<AstNode> = {
    // TODO other terms?
    // TODO does this even work?
    Literal,
    "(" <Exp> ")"
};

Literal: Rc<AstNode> = {
    "true"  => Rc::new(AstNode::Literal{ lit: Lit::LitTrue }),
    "false" => Rc::new(AstNode::Literal{ lit: Lit::LitFalse }),
    <i:r"[0-9]+"> <f:r"(\.[0-9]+)"?> => match f {
        None => Rc::new(AstNode::Literal{ lit: Lit::LitInt(i32::from_str(i).unwrap()) }),
        Some(f) => Rc::new(AstNode::Literal { lit: Lit::LitFloat(format!("{}{}", i, f).parse().unwrap()) }),
    }
};

Ident: String = {
    r"[a-zA-Z_]+[a-zA-Z0-9_]*" => String::from(<>),
};

VarId: String = {
    "$" <i:Ident> => i,
};

GlobId: String = {
    Ident
};


Type: Box<Type> = {
    "int"   => Box::new(Type::IntType),
    "cint"  => Box::new(Type::CIntType),
    "float" => Box::new(Type::FloatType),
    "bool"  => Box::new(Type::BoolType),
    "void"  => Box::new(Type::VoidType),
    <na:"(noalias)"?> "ref" <t:Type> => match na {
        None    => Box::new(Type::Ref(false, t)),
        Some(_) => Box::new(Type::Ref(true, t)),
    }
};

VDecls: Vec<Rc<AstNode>> = {
    <vs:(<VDecl> ",")*> <v:VDecl> => {
        let mut vs = vs;
        vs.push(v);
        vs
    }
}

VDecl: Rc<AstNode> = {
    <t:Type> <i:VarId> => Rc::new(AstNode::VDecl{
        type_: t,
        varid: i,
    })
}
