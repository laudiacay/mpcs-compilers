use std::str::FromStr;
use std::rc::Rc;
use crate::ast::*;

grammar;

// macro for precedence climbing for binary operations
Tier<Op,NextTier>: Rc<AstNode> = {
    <l:Tier<Op,NextTier>> <bop:Op> <r:NextTier> => Rc::new(AstNode::BinOp{
        op: bop,
        lhs: l,
        rhs: r,
    }),
    NextTier
};

// comma-separated list macro
List<Decl>: Vec<Rc<AstNode>> = {
    <ds:(<Decl> ",")*> <d:Decl> => {
        let mut ds = ds;
        ds.push(d);
        ds
    }
}


// rule for the entire program
// used to generate the actual parser in main.rs
pub Prog: Rc<AstNode> = {
    <e:Extern*> <f:(Func+)> => Rc::new(AstNode::Prog{
        externs: e, 
        funcs: f,
    })
};

Extern: Rc<AstNode> = {
    "extern" <t:Type> <gid:GlobId> "(" <tds:TDecls?> ")" ";" => Rc::new(AstNode::Extern{
        type_: t,
        globid: gid,
        tdecls: tds,
    })
};

Func: Rc<AstNode> = {
    "def" <t:Type> <gid:GlobId> "(" <vs:(VDecls)?> ")" <b:Blk> => Rc::new(AstNode::Func{
        type_: t,
        globid: gid,
        vdecls: vs,
        blk: b,
    }),
};

Blk: Rc<AstNode> = {
    "{" <s:(Stmts)?> "}" => Rc::new(AstNode::Blk{ stmts: s }),
};

Stmts: Vec<Rc<AstNode>> = {
    <s:(Stmt)+> => s,
};

Stmt: Rc<AstNode> = {
    Blk,
    "return" <e:(Exp)?> ";" => Rc::new(AstNode::ReturnStmt{
        exp: e,
    }),
    <v:VDecl> "=" <e:Exp> ";" => Rc::new(AstNode::VDeclStmt{
        vdecl: v,
        exp: e,
    }),
    <e:Exp> ";" => Rc::new(AstNode::ExpStmt{
        exp: e,
    }),
    "while" "(" <c:Exp> ")" <s:Stmt> => Rc::new(AstNode::WhileStmt{
        cond: c,
        stmt: s,
    }),
    "if" "(" <c:Exp> ")" <s:Stmt> <e:("else" <Stmt>)?> => Rc::new(AstNode::IfStmt{
        cond: c,
        stmt: s,
        else_stmt: e,
    }),
    "print" <e:Exp> ";" => Rc::new(AstNode::PrintStmt{
        exp: e,
    }), 
    "print" <s:Slit> ";" => Rc::new(AstNode::PrintStmtSlit {
        string: s,
    }),
};

Exps = List<Exp>;

// lowest-precedence expressions
// see Term for highest prec., -Op rules for other precedences
Exp: Rc<AstNode> = {
    Assignment,
    BinOp,
};

Assignment: Rc<AstNode> = {
    <v:VarId> "=" <e:Exp> => Rc::new(AstNode::Assign{
        varid: v,
        exp: e,
    }),
};

// all binary operations excluding casts and assignments
BinOp: Rc<AstNode> = {
    // logic operations are lower-precedence than arithmetic, so check those first
    LogicOps
};

LogicOpsOp: BOp = {
    "||" => BOp::Or    
};
LogicOps = Tier<LogicOpsOp, LogicAnd>;

AndOp: BOp = {
    "&&" => BOp::And
};
LogicAnd = Tier<AndOp, LogicEq>;

EqOp: BOp = {
    "==" => BOp::EqTo,
};
LogicEq = Tier<EqOp, LogicComp>;

CompOp: BOp = {
    "<" => BOp::Lt,
    ">" => BOp::Gt,
};
LogicComp = Tier<CompOp, ArithOps>; // we're ready to do arithmetic

ArithOpsOp: BOp = {  // how do you name things
    "+" => BOp::Add,
    "-" => BOp::Sub,
};
ArithOps = Tier<ArithOpsOp, ArithFactor>;

FactorOp: BOp = {
    "*" => BOp::Mult,
    "/" => BOp::Div
};

ArithFactor = Tier<FactorOp, TypeCast>;

// Expressions that need to be parsed first (including high-precedence ops, literals, etc.)
Term: Rc<AstNode> = {
    "(" <Exp> ")"
    Literal,
    VarId,
    FuncCall,
};

// Needed to put these in the precedence chain somewhere, arbitrarily decided
TypeCast: Rc<AstNode> = {
    "[" <t:Type> "]" <e:TypeCast> => Rc::new(AstNode::Cast{
        type_: t,
        exp: e,
    }),
    UOp,
};

UOp: Rc<AstNode> = {
    "!" <e:UOp> => Rc::new(AstNode::UOp{
        op: BitwiseNeg,
        exp: e,
    }),
    "-" <e:UOp> => Rc::new(AstNode::UOp{
        op: SignedNeg,
        exp: e,
    }),
    Term,
};

Literal: Rc<AstNode> = {
    "true"  => Rc::new(AstNode::Literal{ lit: Lit::LitTrue }),
    "false" => Rc::new(AstNode::Literal{ lit: Lit::LitFalse }),
    <i:r"[0-9]+"> <f:r"(\.[0-9]+)"?> => match f {
        None => Rc::new(AstNode::Literal{ lit: Lit::LitInt(i32::from_str(i).unwrap()) }),
        Some(f) => Rc::new(AstNode::Literal { lit: Lit::LitFloat(format!("{}{}", i, f).parse().unwrap()) }),
    }
};


FuncCall: Rc<AstNode> = {
    <g:GlobId> "(" <e:Exps?> ")" => Rc::new(AstNode::FuncCall{
        globid: g,
        exps: e,
    }),
};

Slit: String = {
    r#""[^"\n\r]*""# => String::(<>),
};

Ident: String = {
    r"[a-zA-Z_]+[a-zA-Z0-9_]*" => String::from(<>),
};

VarId: String = {
    "$" <i:Ident> => i,
};

GlobId: String = {
    Ident
};

Type: Box<Type> = {
    "int"   => Box::new(Type::IntType),
    "cint"  => Box::new(Type::CIntType),
    "float" => Box::new(Type::FloatType),
    "bool"  => Box::new(Type::BoolType),
    "void"  => Box::new(Type::VoidType),
    <na:"(noalias)"?> "ref" <t:Type> => match na {
        None    => Box::new(Type::Ref(false, t)),
        Some(_) => Box::new(Type::Ref(true, t)),
    }
};

TDecls = List<Type>;

VDecls = List<VDecl>;

VDecl: Rc<AstNode> = {
    <t:Type> <i:VarId> => Rc::new(AstNode::VDecl{
        type_: t,
        varid: i,
    })
}
